/*! @module Public
 */

/*! @module EJDB
 */

#define _GNU_SOURCE

#include "ejdb_config.h"
#include "util.h"

#if HAVE_TCEJDB_EJDB_H
#include <tcejdb/ejdb.h>
#endif /* HAVE_TCEJDB/EJDB_H */

extern struct program * EJDB_program;

void throw_ejdb_error(struct object * db);
EJDB * getdb(struct object * db);

DECLARATIONS

PIKECLASS Collection
{
  DECLARATIONS
  CVAR EJCOLL * coll;
  PIKEVAR object db;

#define COLL_DB(X) (EJDB *)(OBJ2_DB(X))
  PIKEFUN void create()
  {

  }

    PIKEFUN int delete_bson(string oid)
    {
      bson_oid_t _oid;
      int ret;
      
      if(!THIS->coll)
      {
        pop_n_elems(args);
        Pike_error("Collection not initialized properly.\n");
      }

      if(oid && !oid->len)
      {
        pop_n_elems(args);
        Pike_error("OID cannot be a zero-length string.\n");
      }

      bson_oid_from_string(&_oid, oid->str);

      if((ret = ejdbrmbson(THIS->coll, &_oid)))
      {
        pop_stack();
        push_int(0);
      }
      else
      {
          int ecode = ejdbecode(getdb(THIS->db)); 
  //        printf("ecode: %d\n", ecode);
          if (ecode != TCESUCCESS) {
          pop_stack();
    //          printf("throwing error.\n");
              throw_ejdb_error(THIS->db);
              }
      }
    }

  PIKEFUN string load_bson(string oid)
  {
    bson_oid_t _oid;
    bson * _bson;

    if(!THIS->coll)
    {
      pop_n_elems(args);
      Pike_error("Collection not initialized properly.\n");
    }

    if(oid && !oid->len)
    {
      pop_n_elems(args);
      Pike_error("OID cannot be a zero-length string.\n");
    }

    bson_oid_from_string(&_oid, oid->str);

    if((_bson = ejdbloadbson(THIS->coll, &_oid)))
    {
      struct pike_string * bsonStr;
//      bson_print_raw(stdout, bson_data(_bson), 10);
      bsonStr = make_shared_binary_string(bson_data(_bson), bson_size(_bson));
     // bson_destroy(&_bson);
      RETURN bsonStr;
    }
    else
    {
        int ecode = ejdbecode(getdb(THIS->db)); 
        if (ecode != TCESUCCESS) {
  pop_stack();
            throw_ejdb_error(THIS->db);
            }
      pop_stack();
      push_int(0);
    }
  }

  PIKEFUN string save_bson(string bsonval, string|void oid, int|void merge)
  {
    bson_oid_t _oid;
    bson _bson;
    int _merge = 0;

    if(!THIS->coll)
    {
      pop_n_elems(args);
      Pike_error("Collection not initialized properly.\n");
    }

    if(oid && !oid->len)
    {
      pop_n_elems(args);
      Pike_error("OID cannot be a zero-length string.\n");
    }
    else if(oid)
    {
      bson_oid_from_string(&_oid, oid->str);
    }

    if(merge->type == T_INT)
    {
      _merge = merge->u.integer;
    }

    bson_init_finished_data(&_bson, bsonval->str);
 //   bson_print_raw(stdout, bson_data(&_bson), 10);
    
    if(ejdbsavebson2(THIS->coll, &_bson, &_oid, merge))
    {
      struct pike_string * oidStr;
      char c[24];
      bson_oid_to_string((const bson_oid_t *)&_oid, (char *)&c);

      oidStr = make_shared_binary_string(c, strlen(c));
      //bson_destroy(&_bson);
      RETURN oidStr;
    }
    else
    {
          int ecode = ejdbecode(getdb(THIS->db)); 
          if (ecode != TCESUCCESS) {
            pop_stack();
              throw_ejdb_error(THIS->db);
              }
    
      RETURN 0;
    }

  }

  PIKEFUN array find(string bson_query)
  {
    bson _bson;
    EJQ *q1;
    uint32_t count;
    TCLIST *res;
    int i;
    
    if(!THIS->coll)
    {
      pop_n_elems(args);
      Pike_error("Collection not initialized properly.\n");
    }
    
    bson_init_finished_data(&_bson, bson_query->str);
 //  bson_print_raw(stdout, bson_data(&_bson), 10);
    
    q1 = ejdbcreatequery(getdb(THIS->db), &_bson, NULL, 0, NULL);

    res = ejdbqryexecute(THIS->coll, q1, &count, 0, NULL);
 //   fprintf(stderr, "\n\nRecords found: %d\n", count);

    pop_stack();

    //Now print the result set records
    for (i = 0; i < TCLISTNUM(res); ++i) {
    struct pike_string * bt;
      bson *bsdata = (bson *)TCLISTVALPTR(res, i);
      // TODO: find a more efficient approach to this (as in, do we really need the length in order to make the pike_string?)
      bson_init_finished_data(&_bson, bsdata);
//      bson_print_raw(stderr, bsdata, 0);
      
      bt = make_shared_binary_string(bson_data(&_bson), bson_size(&_bson));
      push_string(bt);
      }
    fprintf(stderr, "\n");
    f_aggregate(count);

    //Dispose result set
    tclistdel(res);

    //Dispose query
    ejdbquerydel(q1);
 //   bson_destroy(&_bson);
  }
  
  INIT
  {
  }

  EXIT
  {
    if(THIS->coll)
        free(THIS->coll);
    if(THIS->db)
      free_object(THIS->db);

  }

}

/*! @endclass
 */


/*! @class EJDB
 */
PIKECLASS EJDB
{

DECLARATIONS
CVAR EJDB * jb;

PIKEFUN void create(string dbpath, int flags)
{
  static EJDB *jb;
  jb = ejdbnew();
  if (!ejdbopen(jb, dbpath->str, flags | (JBOWRITER | JBOCREAT | JBOTRUNC))) {
    Pike_error("Unable to open database %s", dbpath->str);
  }
  pop_n_elems(args);
  
  THIS->jb = jb;
  //printf("db: %p\n", THIS->jb);
}

PIKEFUN int sync()
{
   if (!ejdbsyncdb(THIS->jb)) {
       RETURN ejdbecode(THIS->jb);
   }
   else RETURN 0;
}


PIKEFUN int close()
{
   if (!ejdbclose(THIS->jb)) {
       RETURN ejdbecode(THIS->jb);
   }
   else RETURN 0;
}

PIKEFUN object get_collection(string name)
{
  EJCOLL* coll;
  
  coll = ejdbgetcoll(THIS->jb, name->str);
  if(!coll)
  {
    pop_n_elems(args);
    push_int(0);
    return;
  }
  else
  {
    struct object * c;
    c = clone_object(Collection_program, 0);
    OBJ2_COLLECTION(c)->coll = coll;
    OBJ2_COLLECTION(c)->db = this_object();
    add_ref(OBJ2_COLLECTION(c)->db);
    pop_n_elems(args);
    push_object(c);
    return;
  }
}

PIKEFUN object create_collection(string name, mapping|void opts)
{
  EJCOLL* coll;
  EJCOLLOPTS _opts;
  
  coll = ejdbcreatecoll(THIS->jb, name->str, &_opts);
  if(!coll)
  {
    pop_n_elems(args);
    push_int(0);
    return;
  }
  else
  {
    struct object * c;
    c = clone_object(Collection_program, 0);
    OBJ2_COLLECTION(c)->coll = coll;
    OBJ2_COLLECTION(c)->db = this_object();
    add_ref(OBJ2_COLLECTION(c)->db);
    pop_n_elems(args);
    push_object(c);
    return;
  }
}
INIT
{
}

EXIT
{
  if(THIS->jb)
    ejdbclose(THIS->jb);
}

EXTRA
{
  add_integer_constant("JBOREADER", JBOREADER, 0);
  add_integer_constant("JBOWRITER", JBOWRITER, 0);
  add_integer_constant("JBOCREAT", JBOCREAT, 0);
  add_integer_constant("JBOTRUNC", JBOTRUNC, 0);
  add_integer_constant("JBONOLCK", JBONOLCK, 0);
  add_integer_constant("JBOLCKNB", JBOLCKNB, 0);
  add_integer_constant("JBOTSYNC", JBOTSYNC, 0);
}

}

/*! @endclass
 */

/*! @endmodule
 */

/*! @endmodule
 */

 PIKE_MODULE_INIT
 {
   INIT;
 }

 PIKE_MODULE_EXIT
 {
   EXIT;
 }

 EJDB * getdb(struct object * db)
 {
    struct EJDB_struct * _db;
    _db = (OBJ2_EJDB(db));
    return _db->jb; 
 }

 void throw_ejdb_error(struct object * db)
 {
   EJDB * _db;
   int ecode;
   
   _db = getdb(db);
   ecode = ejdbecode(_db);
//printf("throwing error!\n");
   Pike_error(ejdberrmsg(ecode));
 }

