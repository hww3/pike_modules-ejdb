/*! @module Public
 */

/*! @module EJDB
 */

#define _GNU_SOURCE

#include "ejdb_config.h"
#include "util.h"

#if HAVE_TCEJDB_EJDB_H
#include <tcejdb/ejdb.h>
#endif /* HAVE_TCEJDB/EJDB_H */

extern struct program * EJDB_program;

void push_coll(EJCOLL * coll);
void throw_ejdb_error(struct object * db);
EJDB * getdb(struct object * db);

DECLARATIONS

/*! @class Collection
 */
PIKECLASS Collection
{
  DECLARATIONS
  CVAR EJCOLL * coll;
  PIKEVAR object db;

#define COLL_DB(X) (EJDB *)(OBJ2_DB(X))
  PIKEFUN void create()
  {

  }

  /*! @decl int delete_bson(string oid)
   */
    PIKEFUN int delete_bson(string oid)
    {
      bson_oid_t _oid;
      int ret;
      
      if(!THIS->coll)
      {
        pop_n_elems(args);
        Pike_error("Collection not initialized properly.\n");
      }

      if(oid && !oid->len)
      {
        pop_n_elems(args);
        Pike_error("OID cannot be a zero-length string.\n");
      }

      bson_oid_from_string(&_oid, oid->str);

      if((ret = ejdbrmbson(THIS->coll, &_oid)))
      {
        pop_stack();
        push_int(0);
      }
      else
      {
          int ecode = ejdbecode(getdb(THIS->db)); 
  //        printf("ecode: %d\n", ecode);
          if (ecode != TCESUCCESS) {
          pop_stack();
    //          printf("throwing error.\n");
              throw_ejdb_error(THIS->db);
              }
      }
    }

  /*! @decl string load_bson(string oid)
   */
  PIKEFUN string load_bson(string oid)
  {
    bson_oid_t _oid;
    bson * _bson;

    if(!THIS->coll)
    {
      pop_n_elems(args);
      Pike_error("Collection not initialized properly.\n");
    }

    if(oid && !oid->len)
    {
      pop_n_elems(args);
      Pike_error("OID cannot be a zero-length string.\n");
    }

    bson_oid_from_string(&_oid, oid->str);

    if((_bson = ejdbloadbson(THIS->coll, &_oid)))
    {
      struct pike_string * bsonStr;
//      bson_print_raw(stdout, bson_data(_bson), 10);
      bsonStr = make_shared_binary_string(bson_data(_bson), bson_size(_bson));
     // bson_destroy(&_bson);
      RETURN bsonStr;
    }
    else
    {
        int ecode = ejdbecode(getdb(THIS->db)); 
        if (ecode != TCESUCCESS) {
  pop_stack();
            throw_ejdb_error(THIS->db);
            }
      pop_stack();
      push_int(0);
    }
  }

  /*! @decl string save_bson(string bsonval, string|void oid, int|void merge)
   */
  PIKEFUN string save_bson(string bsonval, string|void oid, int|void merge)
  {
    bson_oid_t _oid;
    bson _bson;
    int _merge = 0;

    if(!THIS->coll)
    {
      pop_n_elems(args);
      Pike_error("Collection not initialized properly.\n");
    }

    if(oid && !oid->len)
    {
      pop_n_elems(args);
      Pike_error("OID cannot be a zero-length string.\n");
    }
    else if(oid)
    {
      bson_oid_from_string(&_oid, oid->str);
    }

    if(merge->type == T_INT)
    {
      _merge = merge->u.integer;
    }

    bson_init_finished_data(&_bson, bsonval->str);
 //   bson_print_raw(stdout, bson_data(&_bson), 10);
    
    if(ejdbsavebson2(THIS->coll, &_bson, &_oid, merge))
    {
      struct pike_string * oidStr;
      char c[24];
      bson_oid_to_string((const bson_oid_t *)&_oid, (char *)&c);

      oidStr = make_shared_binary_string(c, strlen(c));
      //bson_destroy(&_bson);
      RETURN oidStr;
    }
    else
    {
          int ecode = ejdbecode(getdb(THIS->db)); 
          if (ecode != TCESUCCESS) {
            pop_stack();
              throw_ejdb_error(THIS->db);
              }
    
      RETURN 0;
    }

  }

  /*! @decl array find(string bson_query)
   */
  PIKEFUN array find(string bson_query)
  {
    bson _bson;
    EJQ *q1;
    uint32_t count;
    TCLIST *res;
    int i;
    
    if(!THIS->coll)
    {
      pop_n_elems(args);
      Pike_error("Collection not initialized properly.\n");
    }
    
    bson_init_finished_data(&_bson, bson_query->str);
 //  bson_print_raw(stdout, bson_data(&_bson), 10);
    
    q1 = ejdbcreatequery(getdb(THIS->db), &_bson, NULL, 0, NULL);

    res = ejdbqryexecute(THIS->coll, q1, &count, 0, NULL);
 //   fprintf(stderr, "\n\nRecords found: %d\n", count);

    pop_stack();

    //Now print the result set records
    for (i = 0; i < TCLISTNUM(res); ++i) {
    struct pike_string * bt;
      char *bsdata = (char *)TCLISTVALPTR(res, i);
      // TODO: find a more efficient approach to this (as in, do we really need the length in order to make the pike_string?)
      bson_init_finished_data(&_bson, bsdata);
//      bson_print_raw(stderr, bsdata, 0);
      
      bt = make_shared_binary_string(bson_data(&_bson), bson_size(&_bson));
      push_string(bt);
      }
    fprintf(stderr, "\n");
    f_aggregate(count);

    //Dispose result set
    tclistdel(res);

    //Dispose query
    ejdbquerydel(q1);
 //   bson_destroy(&_bson);
  }
  
  INIT
  {
  }

  EXIT
  {
  //  if(THIS->coll)
    //    free(THIS->coll);
    if(THIS->db)
      free_object(THIS->db);

  }

}

/*! @endclass
 */


/*! @class EJDB
 */
PIKECLASS EJDB
{

DECLARATIONS
CVAR EJDB * jb;

/*! @decl void create(string dbpath, int flags)
 */
PIKEFUN void create(string dbpath, int flags)
{
  static EJDB *jb;
  jb = ejdbnew();
  if (!ejdbopen(jb, dbpath->str, flags)) {
    Pike_error("Unable to open database %s", dbpath->str);
  }
  pop_n_elems(args);
  
  THIS->jb = jb;
  //printf("db: %p\n", THIS->jb);
}

/*! @decl int sync()
 */
PIKEFUN int sync()
{
   if (!ejdbsyncdb(THIS->jb)) {
       RETURN ejdbecode(THIS->jb);
   }
   else RETURN 0;
}

/*! @decl int is_open()
 */
PIKEFUN int is_open()
{
   RETURN (ejdbisopen(THIS->jb));
}

/*! @decl int close()
 */
PIKEFUN int close()
{
   if (!ejdbclose(THIS->jb)) {
       RETURN ejdbecode(THIS->jb);
   }
   else RETURN 0;
}

/*! @decl array(object) get_collections()
 */
PIKEFUN array get_collections()
{
  TCLIST *colls;
  int i;

  colls = ejdbgetcolls(THIS->jb);
  
  for (i = 0; i < TCLISTNUM(colls); ++i) {
    EJCOLL *coll = (EJCOLL *)TCLISTVALPTR(colls, i);
    push_coll(coll);
  }
  
  f_aggregate(TCLISTNUM(colls));

  //Dispose result set
  tclistdel(colls);
}

/*! @decl object get_collection(string name)
 */
PIKEFUN object get_collection(string name)
{
  EJCOLL* coll;
  
  ref_push_string(name);
  f_string_to_utf8(1);
    
  coll = ejdbgetcoll(THIS->jb, (name->str));

printf("coll: %p\n", coll);
  if(!coll)
  {
    pop_n_elems(args + 1);
    push_int(0);
    return;
  }
  else
  {
    pop_n_elems(args + 1);
    push_coll(coll);
    return;
  }
}

/*! @decl create_collection(string name, mapping|void opts) 
  */
PIKEFUN object create_collection(string name, mapping|void opts)
{
  EJCOLL* coll;
  EJCOLLOPTS _opts;

  ref_push_string(name);
  f_string_to_utf8(1);
  name = Pike_sp[0-1].u.string;
  coll = ejdbcreatecoll(THIS->jb, (name->str), &_opts);
  if(!coll)
  {
    pop_n_elems(args + 1);
    push_int(0);
    return;
  }
  else
  {
    pop_n_elems(args + 1);
    push_coll(coll);
    return;
  }
}

void push_coll(EJCOLL * coll)
{
  struct object * c;
  c = clone_object(Collection_program, 0);
  OBJ2_COLLECTION(c)->coll = coll;
  OBJ2_COLLECTION(c)->db = this_object();
  add_ref(OBJ2_COLLECTION(c)->db);
  push_object(c);
}

INIT
{
}

EXIT
{
  EJDB * jb;
  jb = THIS->jb;
  if(jb && ejdbisopen(jb))
  { 
    printf("closing\n");
    ejdbclose(jb);
  }
  if(jb)
  {
    printf("freeing\n");
    ejdbdel(jb);
  }
}

EXTRA
{
  /*! @constant JBOREADER */
  add_integer_constant("JBOREADER", JBOREADER, 0);

  /*! @constant JBOWRITER */
  add_integer_constant("JBOWRITER", JBOWRITER, 0);

  /*! @constant JBOCREAT */
  add_integer_constant("JBOCREAT", JBOCREAT, 0);

  /*! @constant JBOTRUNC */
  add_integer_constant("JBOTRUNC", JBOTRUNC, 0);

  /*! @constant JBONOLCK */
  add_integer_constant("JBONOLCK", JBONOLCK, 0);

  /*! @constant JBOLCKNB */
  add_integer_constant("JBOLCKNB", JBOLCKNB, 0);

  /*! @constant JBOTSYNC */
  add_integer_constant("JBOTSYNC", JBOTSYNC, 0);
}

}

/*! @endclass
 */

/*! @endmodule
 */

/*! @endmodule
 */

 PIKE_MODULE_INIT
 {
   INIT;
 }

 PIKE_MODULE_EXIT
 {
   EXIT;
 }

 EJDB * getdb(struct object * db)
 {
    struct EJDB_struct * _db;
    _db = (OBJ2_EJDB(db));
    return _db->jb; 
 }

 void throw_ejdb_error(struct object * db)
 {
   EJDB * _db;
   int ecode;
   
   _db = getdb(db);
   ecode = ejdbecode(_db);
//printf("throwing error!\n");
   Pike_error(ejdberrmsg(ecode));
 }

